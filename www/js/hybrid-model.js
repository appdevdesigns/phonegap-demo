'use strict';

import can from 'can';
import Comm from './comm';
import Model from './model';
import LocalModel from './local-model';
import RemoteModel from './remote-model';
import HTTPRequest from './models/httpRequest';

const staticProperties = {
  currentMode: 'default',

  // Execute the code inside the "operation" function in the specified mode
  // This allows the HybridModel to temporary act as a LocalModel or a RemoteModel for a certain operation
  runInMode(mode, operation) {
    this.currentMode = mode;
    operation();
    this.currentMode = 'default';
  },

  // Synchronize the client and the server
  sync(localModels) {
    // Sync client changes to the server and then sync server changes to the client after that finishes
    this.syncRemoteWithLocal().then(() => {
      RemoteModel.findAll.call(this).then(remoteModels => {
        this.syncLocalWithRemote(localModels, Array.from(remoteModels));
      });
    }).catch(() => {
      // Syncing local changes to the server failed, so simply try again later
    });
  },

  // Attempt to apply on the server all transactions that have been queued on the client
  syncRemoteWithLocal() {
    // This promise dance ensures that the requests run in series
    let promise = Promise.resolve();
    HTTPRequest.list.forEach(requestModel => {
      promise = promise.then(() => {
        // Attempt to apply the request on the server
        // When it finishes, remove that request from the queue by removing the model from the database
        const options = requestModel.attr('options');
        return Comm.request(options).then(() => {
          requestModel.destroy();
        }).catch(err => {
          console.error(err);
        });
      });
    });
    return promise;
  },

  // Update the local database to match the model list found on the server
  syncLocalWithRemote(localModels, remoteModels) {
    /// Use the list of all models existing locally in the application
    /// const localModels = Array.from(this.list);

    // Generate a set of all the ids present in either the local or remote model lists
    const id = model => model.getId();
    const allIds = new Set([...localModels.map(id), ...remoteModels.map(id)]);

    // Create a map for the local and remote models to support the efficient lookup of a model given its id
    const entries = model => [model.getId(), model];
    const localModelsMap = new Map(localModels.map(entries));
    const remoteModelsMap = new Map(remoteModels.map(entries));

    for (const id of allIds) {
      // Call the appropriate method (either save or destroy) on the LocalModel class, which will
      // either save or destroy the model on the local database
      const remoteModel = remoteModelsMap.get(id) || null;
      if (remoteModel) {
        // Create or update the model locally because it exists on the server
        this.runInMode('local', () => remoteModel.save());
      } else {
        // Destroy the model locally because it does not exist on the server
        const localModel = localModelsMap.get(id);
        this.runInMode('local', () => localModel.destroy());
      }
    }
  },

  install() {
    const localPromise = LocalModel.install.apply(this, arguments);
    const remotePromise = RemoteModel.install.apply(this, arguments);
    return Promise.all([localPromise, remotePromise]);
  },

  findAll() {
    const promise = LocalModel.findAll.apply(this, arguments);
    promise.then(localModels => {
      this.sync(Array.from(localModels));
    });
    return promise;
  },

  findOne() {
    this.sync();
    return LocalModel.findOne.apply(this, arguments);
  },

  create() {
    const runLocal = () => LocalModel.create.apply(this, arguments);
    const runRemote = () => RemoteModel.create.apply(this, arguments);

    if (this.currentMode === 'local') {
      return runLocal();
    } else if (this.currentMode === 'remote') {
      return runRemote();
    } else if (this.currentMode === 'default') {
      // Run the remote create after the local create so that the model sent to the remote server will
      // include the primary key generated by the client
      return runLocal().then(model => {
        runRemote();
        return model;
      });
    }
  },

  update() {
    const runLocal = () => LocalModel.update.apply(this, arguments);
    const runRemote = () => RemoteModel.update.apply(this, arguments);

    if (this.currentMode === 'local') {
      return runLocal();
    } else if (this.currentMode === 'remote') {
      return runRemote();
    } else if (this.currentMode === 'default') {
      // Run the local update and remote update in parallel because they are not dependent on each other
      runRemote();
      return runLocal();
    }
  },

  destroy() {
    const runLocal = () => LocalModel.destroy.apply(this, arguments);
    const runRemote = () => RemoteModel.destroy.apply(this, arguments);

    if (this.currentMode === 'local') {
      return runLocal();
    } else if (this.currentMode === 'remote') {
      return runRemote();
    } else if (this.currentMode === 'default') {
      // Run the local destroy and remote destroy in parallel because they are not dependent on each other
      runRemote();
      return runLocal();
    }
  },
};

const mergedStaticProperties = can.extend({}, LocalModel, RemoteModel, staticProperties);
const mergedPrototypeProperties = can.extend({}, LocalModel.prototype, RemoteModel.prototype);

export default Model.extend('HybridModel', mergedStaticProperties, mergedPrototypeProperties);
